//! # Storage Utils
//!
//! Вспомогательные функции для работы с энергонезависимым хранилищем.
//! Основная задача крейта — расчет корректных размеров рабочих буферов
//! для библиотеки `sequential-storage`.

use postcard::experimental::max_size::MaxSize;

/// Служебные параметры библиотеки `sequential-storage` (v7.1.0).
/// Эти константы определяют оверхед, который библиотека добавляет к каждому объекту
/// при его упаковке в "Item" (запись) внутри Flash-памяти.
mod overhead {
    /// Заголовок записи (Header): тип, длина и контрольная сумма самого заголовка.
    const ITEM_HEADER: usize = 4;

    /// Размер ключа (Key): В нашем случае используется `u8` (ConfigKey).
    const KEY_SIZE: usize = core::mem::size_of::<u8>();

    /// Контрольная сумма данных (CRC32): Библиотека дописывает её в конец записи
    /// для проверки целостности содержимого конфига.
    const DATA_CRC: usize = 4;

    /// Максимальное выравнивание (Alignment): Зависит от аппаратных требований Flash ESP32.
    /// Резервируем 16 байт для гарантии совместимости с любыми режимами записи (1, 4, 8, 16 байт).
    const MAX_ALIGNMENT: usize = 16;

    /// Суммарное количество служебных байтов на одну запись.
    pub const TOTAL: usize = ITEM_HEADER + KEY_SIZE + DATA_CRC + MAX_ALIGNMENT;
}

/// Рассчитывает оптимальный размер рабочего буфера (scratchpad) для операций
/// чтения и записи во Flash-память.
///
/// Размер буфера включает в себя:
/// 1. Максимально возможный размер данных после сериализации через `postcard`.
/// 2. Служебный оверхед библиотеки `sequential-storage`.
/// 3. Округление до ближайшей степени двойки для эффективного выравнивания в RAM.
///
/// # Type Parameters
/// * `T`: Тип данных, реализующий `MaxSize`, который будет храниться в памяти.
pub const fn buffer_size<T: MaxSize>() -> usize {
    next_power_of_two(T::POSTCARD_MAX_SIZE + overhead::TOTAL)
}

/// Вычисляет ближайшую степень двойки, большую или равную `n`.
///
/// Используется для выравнивания буферов на стеке, что критично для
/// стабильной работы контроллеров ESP32 в async-задачах.
const fn next_power_of_two(n: usize) -> usize {
    if n == 0 {
        return 1;
    }
    let mut val = 1;
    while val < n {
        val <<= 1;
    }
    val
}
